#version 450 core
// The format of the coordinates being outputted by the primitive generator
layout(triangles, equal_spacing, ccw) in;

// Linear interpolation functions for vec3s and vec2s
vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2) ;
vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2) ;

layout(std140) uniform Camera
{
	mat4 u_view;
	mat4 u_projection;
	vec3 u_viewPos;
};

// Unedited vertex data from the TCS
in TCS_OUT {
	vec2 TexCoords;
	flat int TexUnit;
	vec4 Tint;
	vec3 FragPos;
} tes_in[];

// Fragment requires vertex data
out TES_OUT {
	vec2 TexCoords;
	flat int TexUnit;
	vec4 Tint;
} tes_out;

void main()
{
   // interpolate the normal and xyz position using the linear interpolation function
   // use 3D because they are in three dimensions; 2D also included for uv texture coordinates
   tes_out.TexCoords = interpolate2D(tes_in[0].TexCoords, tes_in[1].TexCoords, tes_in[2].TexCoords);
   tes_out.TexUnit = tes_in[0].TexUnit;
   tes_out.Tint = tes_in[0].Tint;
   vec3 pos = interpolate3D(tes_in[0].FragPos, tes_in[1].FragPos, tes_in[2].FragPos);

   // transform vertex position to clip space  - NOTE: WE NEED TO DO IT HERE NOW and not in vertex shader
   gl_Position = u_projection * u_view * vec4(pos, 1.0);
} 

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
	// gl_TessCoord is the baycentric coordinate generated
   	return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
	// gl_TessCoord is the baycentric coordinate generated
   	return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}